# 問題2解説

### 考え方
2つの商品の重さをそれぞれ `(A, B)` とすると、 `X = A × B` と表すことができます。
Aが決まれば、Bの値が決まる`(B = X / A)`ので、Aに対応するBを探せばOK。

まずは、端から順番にAを決定し、Aに対応するBを探す方法を考えてみます。
例で考えてみると、左端の1をAと置きます。
そうすると、 `B = 10 / 1` なので10だとわかります。
例題で出てきた半分に区切る方法で10を探せばいいですね。
これを、Aを右にずらしながら商品数の分だけ繰り返すと、 `X = A × B` となる要素の組み合わせの個数がわかります。
制約から、数列の長さは10<sup>5</sup>なので、計算回数は、

<pre>
10<sup>5</sup> (商品数) × log10<sup>5</sup> (商品の中からBを探す回数) = 10<sup>5</sup>log10<sup>5</sup> = 5 × 10<sup>5</sup> log10 回になります。
</pre>

となります。(商品の中からBを探す回数についての説明はここでは割愛します。)
Bを探すときに半分に区切る方法を使っているので、全パターンを探すよりは少ない回数で探せますが、もっと少ない回数で探す方法があります。

### 別解

1. 10<sup>5</sup>の長さのboolean型配列Fを用意する
1. S<sub>i</sub>をPとすると、F<sub>P</sub>をTrueにする
1. S<sub>i</sub>がAのとき `B = X × A` とすると、F<sub>B</sub>がTrueであれば `X = A × B` が存在することがわかる
1. F<sub>B</sub>をFalseにし、3を繰り返す

数列Sの要素の最大値分の長さのboolean型配列を用意します。つまり、10<sup>5</sup>の長さの配列Fです。
数列Sのi番目の値をPとすると、F<sub>P</sub> ( 配列FのP番目 ) をTrueにします。
先ほど説明した通り、Aが決まればBも決まるので、あるAを決定したときに、F<sub>B</sub>がTrueかどうか見ればBがあるかどうかわかります。
この方法だと、数列Sの長さ分だけの計算で済むので、計算回数は 10<sup>5</sup> 回となる。