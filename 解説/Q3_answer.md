# [解説] 問題3 整数解

## 問題の取っ掛かり

この問題を解く上での重要なのは「割り算のあまり」です。
解答の整数`(x,y)`には制約がないため、もし整数解が存在しない場合、すべての`(x,y)`を確かめるというアルゴリズムは不可能です（無限の時間の存在を許せば可能です）。
したがって、ある一定量の数を調べるだけで "Yes" か "No" かを判定できるアルゴリズムを考える必要があります。

## 調べる数を絞る

### 問題を見て気づくこと

簡単にするため、`|A| > |B|` とします（ `A` と `B` は入れ替えても解に影響はないため）。
`Ax + By = 1`となるためには、`|Ax|` を `|B|` で割った時のあまりが1になれば良いことがわかります。このとき、商が `y` になります。

### 割った時のあまりについて考える

`|Ax|` を `|B|` で割った時のあまりは当然 `x` に依存します。
そこで `x = 1` から順番に1ずつ大きくしながら代入すると、割った時のあまりが循環していることに気づくでしょう。
したがって、最大でも `x = |B|` まで調べれば良いことがわかります。

### ひとまずの解答

したがって、アルゴリズムとしては以下のようになります。
1. `|Ax|` を `|B|` で割った時のあまりを `x = 1` から順番に1ずつ増やして調べる
1. あまりが1になるものが存在すれば、その時点で "Yes"
1. `x = |B|` まで調べても1になるものが存在しなければ "No"

## もっと簡単に解く方法

実はこの問題は `A` と `B` の最大公約数が 1 かどうかで "Yes" か "No" かがわかります。
正式な証明は別資料にて解説しますが、最大公約数が 1 の場合、上記　`|Ax|` を `|B|` で割った時のあまりは `0` から `|B| - 1` までのすべての値を取ります。逆に最大公約数が 1 ではない場合、`0` は必ず通った上で `|B| - 1` までの内最大公約数分飛ばした数だけを取ります。
また、最大公約数はユークリッドの互除法によって導出できるので、操作の回数は `log|A|` となります。

### 具体例

`A = 18, B = 10` の場合、最大公約数は 2 です。`x = 1` から順番にあまりを羅列していくと、`8, 6, 4, 2, 0, 8, ...` となるため、0 から 9 までの偶数が並んでいることがわかります。

## 結論

考えられるのは以下の3通りです。

1. 考えうる整数の組 `(x, y)` をすべて当てはめる → 無限通りあるため不可能
1. `|Ax|` を `|B|` で割った時のあまりについて `x=1` から `x=|B|` まで代入して判定する → 最大 `|B|` 回の操作が必要
1. `|A|` と `|B|` の最大公約数で判定する → `log|A|`回の操作で判定できる